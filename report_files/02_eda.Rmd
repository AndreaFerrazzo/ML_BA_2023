# EDA

## Nutrution EDA

### Visual exploration - Univariate Analysis

#### Rating Barplot

```{r}

recipes %>% 
  ggplot(aes(x=as.factor(rating), fill=as.factor(rating) )) +  
  geom_bar( ) +
  scale_fill_manual(values = c("red4", "red3", "orangered", "orange", "gold", "greenyellow", "green3", "green4") ) +
  theme(legend.position="none") +
  scale_y_continuous(breaks=seq(0,10000,1000)) +
  labs(x = "Rating", y = "Number of recipes", 
       title = "Overview of recipes' ratings")

```
The data available provide ratings which are separated in 7 distinct categories, which span from 1.25 to 5. We do not forget that we decided to exclude recipes with rating equal to zero.
As we can see, most of the ratings have value equal or above 3.75, more in particular we notice that most of the recipes have ratings of 4.375.

```{r}

#histograms + density for age, amount and duration

ggplot(credit_data, aes(age)) +
  geom_histogram(aes(y = ..density..), color = "#000000", fill = "#0099F8") +
  geom_density(color = "#000000", fill = "#F85700", alpha = 0.6)+
  labs(x = "Age", y = "Density", title = "Distribution of age")

ggplot(credit_data, aes(amount)) +
  geom_histogram(aes(y = ..density..), color = "#000000", fill = "#0099F8") +
  geom_density(color = "#000000", fill = "#F85700", alpha = 0.6)+
  labs(x = "Amount", y = "Density", title = "Distribution of amount")

ggplot(credit_data, aes(duration)) +
  geom_histogram(aes(y = ..density..), color = "#000000", fill = "#0099F8") +
  geom_density(color = "#000000", fill = "#F85700", alpha = 0.6) +
  labs(x = "Duration", y = "Density", title = "Distribution of duration")

```

#### Calories - Boxplot and Histogram

```{r}

recipes_plot <- recipes %>% 
  pivot_longer(cols = c(calories, protein, fat, sodium),
               names_to = "nutrition",
               values_to = "n_value")

# Calories boxplot not filtered
recipes_plot %>%
  filter(nutrition == "calories") %>% 
  ggplot(aes(x=nutrition, y=n_value, fill=nutrition)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme_light() +
    theme(legend.position="none",
          plot.title = element_text(size=11)) +
  ggtitle("Boxplot of calories nutritional value") +
  xlab("") +
  ylab("Value")


recipes_plot %>% 
  filter(nutrition == "calories") %>% 
  select(title, nutrition, n_value) %>% 
  arrange(desc(n_value)) 
```

We notice that there are recipes with more than 30'000'000 calories which are clearly outliers. It is also hard to interpret these values from the boxplot and even with a density plot we cannot extract any insight. We must then discard those values in order to continue with a meaningful analysis. There are 28 recipes which have more than 7000 calories. We consider those as extreme values which represents 0.27% of the data available. Why do they exist? It could be due to a miscalculation or to an excessive number of servings per recipe. By evaluating the usual number of calories per recipe, we decided to keep those that have a reasonable quantity, i.e., below 7000.

```{r fig.height=5}
# Calories boxplot
df <- recipes_plot %>%
  filter(nutrition == "calories", n_value <= 7000)

boxplot_calories <- df %>% 
  ggplot(aes(x=nutrition, y=n_value, fill=nutrition)) +
  geom_boxplot()+
  scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  theme(legend.position="none",
        plot.title = element_text(size=11)) +
  scale_y_continuous(breaks=seq(0,7000,500)) +
  labs(x = " ", y = "Calories", title = "Boxplot of calories nutritional value filtered")


# Calories histogram
histogram_calories <- df %>% 
  ggplot(aes(x=n_value)) +
  geom_histogram(binwidth=50, fill="red3", color="red3", alpha=0.9) +
  theme(plot.title = element_text(size=11)) +
  scale_x_continuous(breaks=seq(0,10000,1000)) +
  scale_y_continuous(breaks=seq(0,1750,250)) +
  labs(x = "Count", y = "Calories", title = "Distribution of calories across all recipes")


# Calories density plot
density_calories <- df %>% 
  ggplot(aes(x=n_value)) +
  geom_density(fill="red3", color="red2", alpha=0.8) +
  theme(plot.title = element_text(size=11)) +
  scale_x_continuous(breaks=seq(0,10000,1000)) +
  ggtitle("Distribution of calories across all recipes") +
  xlab("Calories")

grid.arrange(boxplot_calories, histogram_calories, density_calories, ncol=3, nrow =1)
```

After filtering extreme values we can observe that most of the recipes have between 200 and 600 calories. By checking with the histogram the distribution of calories, we observe that indeed most of the recipes have less than 1000 calories.


#### Protein - Boxplot and Histogram

```{r}

recipes_plot %>%
  filter(nutrition == "protein") %>% 
  ggplot(aes(x=nutrition, y=n_value, fill=nutrition)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme_light() +
    theme(legend.position="none",
          plot.title = element_text(size=11)) +
  ggtitle("Boxplot of protein nutritional value") +
  xlab("") +
  ylab("Value")
  
```
We notice that there are recipes with more than 50'000 grams of protein which are clearly outliers. We must then discard those values in order to continue with a meaningful analysis. Also from a visual point of view we could not extract any relevant information. By checking on the epicurious website the recipes with protein values above 1000, we verified that such amount of proteins was not justified. We came to that conclusion by evaluating the average values of protein per 100grams of each ingredient in the specific recipe.

```{r fig.height=5}
recipes_plot %>%
  filter(nutrition == "protein") %>% 
  select(title, nutrition, n_value) %>% 
  arrange(desc(n_value)) 


# Proteins boxplot
boxplot_protein <- recipes_plot %>%
  filter(nutrition == "protein", n_value <= 1000) %>% 
  ggplot( aes(x=nutrition, y=n_value, fill=nutrition)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme(legend.position="none",
          plot.title = element_text(size=16)) +
  scale_y_continuous(breaks=seq(0,7000,25)) +
  labs(title="Boxplot of protein nutritional value filtered") +
  xlab("") +
  ylab("Proteins") 


# Proteins histogram
histogram_protein <- recipes_plot %>% 
  filter(nutrition == "protein", n_value <= 1000) %>% 
  ggplot(aes(x=n_value)) +
  geom_histogram(binwidth=7, fill="red3", color="red3", alpha=0.9) +
  scale_x_continuous(breaks=seq(0,1000,50)) +
  scale_y_continuous(breaks=seq(0,7000,250)) +
  theme(legend.position="none",
          plot.title = element_text(size=16)) +
  labs(title="Distribution of proteins across all recipes") +
  xlab("Proteins") +
  ylab("Count") 


# Protein density plot
density_protein <- recipes_plot %>% 
  filter(nutrition == "protein", n_value <= 1000) %>% 
  ggplot(aes(x=n_value)) +
  geom_density(fill="red3", color="red2", alpha=0.8) +
  scale_x_continuous(breaks=seq(0,1000,50)) +
  theme(legend.position="none",
          plot.title = element_text(size=16)) +
  labs(title="Distribution of proteins across all recipes") +
  xlab("Proteins")

grid.arrange(boxplot_protein, histogram_protein, density_protein, ncol=2, nrow =2)

```

From the boxplot, we observe that most recipes have less than 30 grams of proteins. By plotting the histogram, we verify that this information is correct. We could even extend the range to 100 proteins per recipe. We assume that recipes with values above this threshold contain ingredients like meat, tuna, salmon or shrimps.


#### Sodium - Boxplot and Histogram

```{r}

recipes_plot %>%
  filter(nutrition == "sodium") %>% 
  ggplot(aes(x=nutrition, y=n_value, fill=nutrition)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme(legend.position="none",
          plot.title = element_text(size=11)) +
  labs(title="Boxplot of sodium nutritional value") +
  xlab("") +
  ylab("Value")
```
  
We notice that there are recipes with more than 100'000 milligrams of sodium which are clearly outliers. We must then discard those values in order to continue with a meaningful analysis. By conducting further research, we realize that sodium values above 30'000 are highly suspicious.  

```{r fig.height=7}

recipes_plot %>% 
  filter(nutrition == "sodium") %>%
  select(title, nutrition, n_value) %>% 
  arrange(desc(n_value)) 


# Sodium boxplot
boxplot_sodium <- recipes_plot %>%
  filter(nutrition == "sodium", n_value <= 30000) %>% 
  ggplot(aes(x=nutrition, y=n_value, fill=nutrition)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme(legend.position="none",
          plot.title = element_text(size=17)) +
  scale_y_continuous(breaks=seq(0,30000,500)) +
  labs(title="Boxplot of sodium nutritional value") +
  xlab("") +
  ylab("Sodium") 


# Sodium histogram
histogram_sodium <- recipes_plot %>%
  filter(nutrition == "sodium", n_value <= 30000) %>% 
  ggplot(aes(x=n_value)) +
  geom_histogram(binwidth=50, fill="red3", color="red3", alpha=0.9) +
  theme(plot.title = element_text(size=15)) +
  scale_x_continuous(breaks=seq(0,30000,1000)) +
  scale_y_continuous(breaks=seq(0,1750,250)) +
  theme(legend.position="none",
          plot.title = element_text(size=17)) +
  labs(title="Distribution of sodium across all recipes") +
  xlab("Sodium") +
  ylab("Count") 


# Sodium density plot
density_sodium <- recipes_plot %>%
  filter(nutrition == "sodium", n_value <= 30000) %>% 
  ggplot(aes(x=n_value)) +
  geom_density(fill="red3", color="red2", alpha=0.8) +
  scale_x_continuous(breaks=seq(0,30000,1000)) +
  theme(legend.position="none",
          plot.title = element_text(size=17)) +
  labs(title="Distribution of sodium across all recipes") +
  xlab("Sodium") 


grid.arrange(boxplot_sodium, histogram_sodium, density_sodium, ncol=2, nrow =2)
```

From the boxplot we observe that most recipes have sodium values below 750 milligrams. The histogram informs us that most of recipes have indeed less than 750 milligrams of sodium, even though we cannot exclude the presence of a good amount of recipes with sodium between 750 and 2000 milligrams.


#### Fat - Boxplot and Histogram

```{r}
recipes_plot %>%
  filter(nutrition == "fat") %>% 
  ggplot(aes(x=nutrition, y=n_value, fill=nutrition)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme_light() +
    theme(legend.position="none",
          plot.title = element_text(size=11)) +
  labs(title="Boxplot of fat nutritional value") +
  xlab("") +
  ylab("Value")
```

We notice that there are recipes with more than 44'000 grams of fat which are clearly outliers. We must then discard those values in order to continue with a meaningful analysis. By checking on the epicurious website recipes with fat values above 1000, we also verified that the amount of fat was not justified. We came to that conclusion by evaluating the average values of fat per 100grams of each ingredient in the specific recipe.

```{r fig.height=5}
recipes_plot %>% 
  filter(nutrition == "fat") %>% 
  select(title, nutrition, n_value) %>% 
  arrange(desc(n_value)) 

# Fat boxplot
boxplot_fat <- recipes_plot %>%
  filter(nutrition == "fat", n_value <= 40000) %>% 
  ggplot( aes(x=nutrition, y=n_value, fill=nutrition)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme_light() +
    theme(legend.position="none",
          plot.title = element_text(size=16)) +
  scale_y_continuous(breaks=seq(0,3000,100)) +
  labs(title="Boxplot of fat nutritional value filtered") +
  xlab("") +
  ylab("Fat") 


# Fat histogram
histogram_fat <- recipes_plot %>% 
  filter(nutrition == "fat", n_value <= 40000) %>% 
  ggplot(aes(x=n_value)) +
  geom_histogram(binwidth=7, fill="red3", color="red3", alpha=0.9) +
  labs(title="Distribution of fat across all recipes") +
  theme(legend.position="none",
          plot.title = element_text(size=16)) +
  scale_x_continuous(breaks=seq(0,3000,100)) +
  scale_y_continuous(breaks=seq(0,7000,250)) +
  xlab("Fat") +
  ylab("Count") 

# Sodium density plot
density_fat<- recipes_plot %>%
  filter(nutrition == "fat", n_value <= 40000) %>% 
  ggplot(aes(x=n_value)) +
  geom_density(fill="red3", color="red2", alpha=0.8) +
  scale_x_continuous(breaks=seq(0,3000,100)) +
  theme(legend.position="none",
          plot.title = element_text(size=16)) +
  ggtitle("Distribution of sodium across all recipes") +
  xlab("Fat") 

grid.arrange(boxplot_fat, histogram_fat, density_fat, ncol=2)
```
It is hard to interpret the boxplot. There are certain recipes which could have potentially more than 1000 or even 2000 grams of fat because of the high quantity of servings and the use of ingredients such as lamb, duck and bacon. We must then analyse the histogram to have a better overview and we notice that most recipes have fat values below 100 grams.

### Visual exploration - Multivariate Analysis

#### Scatterplots of Rating-Calories
```{r fig.height=5}
#removing 41 outliers we discovered above from the recipes df
recipes <- recipes %>% 
  filter(calories <= 7000, protein <= 1000, sodium <= 30000, fat <= 40000)


# Scatterplot of Rating-Calories
sp1 <- recipes %>% 
  ggplot(aes(x=calories, y=rating)) +
  geom_point(alpha=.5) +
  ggtitle("Scatterplot of rating against calories") +
  xlab("Calories") +
  ylab("Rating")

# Scatterplot of Rating-Protein
sp2 <- recipes %>% 
  ggplot(aes(x=protein, y=rating)) +
  geom_point(alpha=.5) +
  ggtitle("Scatterplot of rating against proteins") +
  xlab("Proteins") +
  ylab("Rating") 

# Scatterplot of Rating-Fat
sp3 <- recipes %>% 
  ggplot(aes(x=fat, y=rating)) +
  geom_point(alpha=.5) +
  ggtitle("Scatterplot of rating against fat") +
  xlab("Fat") +
  ylab("Rating") 

# Scatterplot of Rating-Sodium
sp4 <- recipes %>% 
  ggplot(aes(x=sodium, y=rating)) +
  geom_point(alpha=.5) +
  ggtitle("Scatterplot of rating against sodium") +
  xlab("Sodium") +
  ylab("Rating") 

grid.arrange(sp1, sp2, sp3, sp4, ncol=2, nrow =2)
```
We can observe that the recipes with more than 2000 calories tend to have a higher rating. For instance, few recipes with less than a 3 star rating have more than 2000 calories.

We can observe that the recipes with more than 125 grams of proteins tend to have a higher rating. For instance, few recipes with less than a 3 star rating have more than 125 grams of proteins.

We can observe that the recipes with more than 100 grams of fat tend to have a higher rating. For instance, few recipes with less than a 3 star rating have more than 100 grams of fat.

We can observe that the recipes with more than 5000 milligrams of sodium tend to have a higher rating. For instance, few recipes with less than a 3 star rating have more than 5000 mg of sodium.

#### Correlogram
```{r}
corr_nutritional_values = recipes %>% 
  select(rating, calories, protein, fat, sodium) %>% 
  cor()

corrplot(corr_nutritional_values)

```
The previous scatterplots illuded us that there was somehow a correlation between rating and the nutritional values. This hypothesis has been refuted because the correlation against the rating is almost at zero for all the nutritional values. On the other hand we notice a strong positive correlation between calories and fat as well as between calories and proteins.


#### Grouped Scatter
We decide to plot together the variables which highlight a great level of correlation.
```{r}

# Grouped scatter of calories and fat
recipes_plot1 <- recipes %>% 
  filter(fat <= 400, calories <= 6000) %>% 
  ggplot(aes(x=calories, y=fat, color=rating)) +
  geom_point(alpha=.5) + 
  scale_color_gradientn(colours = rainbow(5))

# Grouped scatter of calories and protein
recipes_plot2 <- recipes %>% 
  filter(protein <= 500, calories <= 6000) %>% 
  ggplot(aes(x=calories, y=protein, color=rating)) +
  geom_point(alpha=.5) + 
  scale_color_gradientn(colours = rainbow(5))

# Grouped scatter of protein and fat
recipes_plot3 <- recipes %>% 
  filter(fat <= 400, protein <= 350) %>% 
  ggplot(aes(x=protein, y=fat, color=rating)) +
  geom_point(alpha=.5) + 
  scale_color_gradientn(colours = rainbow(5))


# Grouped scatter of protein and sodium
recipes_plot4 <- recipes %>% 
  filter(sodium <= 400, protein <= 350) %>%  
  ggplot(aes(x=protein, y=sodium, color=rating)) +
  geom_point(alpha=.5) + 
  scale_color_gradientn(colours = rainbow(5))

grid.arrange(recipes_plot1, recipes_plot2, recipes_plot3, recipes_plot4, ncol=2, nrow =2)
```
We notice a positive correlation between fat and calories as well as between protein and calories. We also see a slightly positive correlation between fat and protein. We tried to understand to what extent the rating could have an impact on such relationships, but the number of ratings above 3 is overwhelming and strongly determines the behavior of these relationships.


## Ingredients EDA

### Feature engineering 
We discovered that the variable "drinks" on it's own had only 11 observations, 4 of which also had the value "drink" equal to 1. Therefore, we decided to merge the two columns to simplify working with a single category called "drink" for all drinks.
```{r Creating ingredients_df}
#Creating a new dataframe with only the ID, title and the ingredients
ingredients_df <- recipes %>% 
  mutate(drink = ifelse(drink == 1 | drinks == 1, 1, 0)) %>% #merging drinks and drink
  select(ID, title, all_of(all_ingredients), rating)
```


#### Creating binary ingredients categories

```{r Adding binary columns for each category - Manual Working version}
ingredients_df_bin <- ingredients_df %>%
  mutate(vegetables_bin = as.numeric(if_any(all_of(vegetables_vec), ~.x == 1, na.rm = TRUE)),
         meats_bin = as.numeric(if_any(all_of(all_meats), ~.x == 1, na.rm = TRUE)),
         fish_bin = as.numeric(if_any(all_of(fish_vec), ~.x == 1, na.rm = TRUE)),
         seafood_bin = as.numeric(if_any(all_of(seafood_vec), ~.x == 1, na.rm = TRUE)),
         herbs_bin = as.numeric(if_any(all_of(herbs_vec), ~.x == 1, na.rm = TRUE)),
         nuts_bin = as.numeric(if_any(all_of(nuts_vec), ~.x == 1, na.rm = TRUE)),
         fruits_bin = as.numeric(if_any(all_of(fruits_vec), ~.x == 1, na.rm = TRUE)),
         cheese_bin = as.numeric(if_any(all_of(cheeses_vec), ~.x == 1, na.rm = TRUE)),
         dairy_bin = as.numeric(if_any(all_of(dairy_vec), ~.x == 1, na.rm = TRUE)),
         spices_bin = as.numeric(if_any(all_of(spices_vec), ~.x == 1, na.rm = TRUE)),
         cereals_bin = as.numeric(if_any(all_of(cereals_vec), ~.x == 1, na.rm = TRUE)),
         carbs_bin = as.numeric(if_any(all_of(carbs_vec), ~.x == 1, na.rm = TRUE)),
         dessert_bin = as.numeric(if_any(all_of(dessert_vec), ~.x == 1, na.rm = TRUE)),
         egg_bin = (egg)
         ) %>% 
  select(ID, title, contains("bin"), everything())
```

The fact that both select the same number of rows makes having general categories redundant in the dataset. They are not useful to create the binary columns, and they are also not useful to compute the total amount of ingredients in each category per recipe --> let's just not include them in the first place

```{r eval=FALSE}

####testing if I still need to include the general category to create the binary column now that I modified the df to only include recipes with ingredients specified
# 
# #6586
# ingredients_df %>%
#   mutate(vegetables_bin = as.factor(as.numeric(if_any(c(vegetable, all_of(vegetables_vec)), ~.x == 1, na.rm = TRUE)))) %>%
#   filter(vegetables_bin == 1)
# 
# #6586
# ingredients_df %>%
#   mutate(vegetables_bin = as.factor(as.numeric(if_any(all_of(vegetables_vec), ~.x == 1, na.rm = TRUE)))) %>%
#   filter(vegetables_bin == 1)
```


#### Creating total ingredients categories

```{r Adding total columns for each category}
ingredients_df_total <- ingredients_df %>%
  mutate(total_ingredients = rowSums(select(., c(all_of(all_ingredients)))),
         total_vegetables = rowSums(select(., c(all_of(vegetables_vec)))),
         total_meat = rowSums(select(., c(all_of(all_meats)))),
         total_fish = rowSums(select(., c(all_of(fish_vec)))),
         total_seafood = rowSums(select(., c(all_of(seafood_vec)))),
         total_herbs = rowSums(select(., c(all_of(herbs_vec)))),
         total_nuts = rowSums(select(., c(all_of(nuts_vec)))),
         total_fruits = rowSums(select(., c(all_of(fruits_vec)))),
         total_cheese = rowSums(select(., c(all_of(cheeses_vec)))),
         total_dairy= rowSums(select(., c(all_of(dairy_vec)))),
         total_spices= rowSums(select(., c(all_of(spices_vec)))),
         total_cereals= rowSums(select(., c(all_of(cereals_vec)))),
         total_carbs = rowSums(select(., c(all_of(carbs_vec)))),
         total_dessert = rowSums(select(., c(all_of(dessert_vec))))
         ) %>% 
  select(ID, title, contains("total"), everything())
```

#### Creating ingredients_df_full
Creating "ingredients_df_full" which contains bin columns, total columns, and original ingredients columns
```{r creating df with bin and total columns}
total_join <- ingredients_df_total %>% 
  select(ID, contains("total"))
  
ingredients_df_full <- ingredients_df_bin %>% 
  left_join(total_join) %>% 
  select(ID, title, rating, contains("bin"), contains("total"), everything())
```

### "Binary" engineered ingredients categories

#### Frequency of ingredients - binary categories

This gives us interesting information about the frequency of each ingredient being present at least once in a recipe. As we can see, there is at least one vegetable in around 6750 recipes out of the 11380 total we have. Inversely, a very low amount of recipes contains at least one type of cereal.
```{r}
#creating a vector with colnames of all the binary columns to be able to select them more easily afterwards
binary_columns <- ingredients_df_bin %>% 
  select(contains("bin")) %>% 
  colnames()

#adding binary columns to ingredients_df
total_categories <- ingredients_df_bin %>% 
  select(ID, all_of(binary_columns)) %>% 
  pivot_longer(-ID, names_to = "category", values_to = "binary_value") %>% 
  group_by(category) %>% 
  summarise(total = sum(binary_value))

#plotting the frequency of binary columns
total_categories %>%
  ggplot(aes(x=reorder(category,total), y=total, fill=total)) +
  geom_bar(stat = "identity") +
  scale_x_discrete(guide = guide_axis(n.dodge=3))+
  scale_fill_viridis() +
  labs(x = "Category", y = "Amount of recipes", title = "Total amount of recipes containing at least one ingredient in defined categories")
```
Most of the recipes contain vegetables, fruits, meats, herbs and carbs, which is not a surprise.
The barplots below give us similar information about the amount of recipe which contain at least one ingredient in each category. The only category for which an ingredient is present at least once in more than 50% of the recipes is vegetables.

```{r}
ingredients_df_bin %>% 
  select(contains("bin")) %>%
  mutate(across(everything(), as.factor)) %>% 
  plot_bar(order_bar = FALSE)
```

#### Relationship between binary ingredients categories and ratings

##### Barplots - 7-level rating variable
We now want to check the relationship between our `rating` variable and all the binary ingredients variables. We first plot this relationships with multilevel barplots.

It is not so straightforward to analyse but we can see that for example recipes with no fish have a higher chance of getting a rating of 5 when compared to recipes with fish in them. Recipes with carbs seem to have the lowest frequency of rating at 5 out of all the binary categories.
```{r}
ingredients_df_bin %>% 
  select(contains("bin"), rating) %>%
  mutate(across(everything(), as.factor)) %>% 
  plot_bar(by = "rating", order_bar = FALSE)
```
##### Correlation plot
We see some somewhat strong negative correlation between vegetables and dessert, and between vegetable and fruits. This makes sense, as these ingredients are rarely found together in recipes. As a side note, we chose to classify tomato as a vegetable and strongly stand by this opinion :)

Concerning positive correlations, we see nuts and desert as highly correlated. This is probably because they go well together in sugary recipes. Additionally, egg and dairy are also slightly positively correlated. This most likely comes from patisserie recipes where eggs and dairy ingredients go hand in hand.

When looking at the correlation of the binary ingredients variables with the 7-level rating (i.e., `rating`), we see that the highest negative correlation is between rating and `carbs_bin` which could sound a bit surprising given the assumed high popularity of pasta for example. The highest positive correlation is with `fruit_bin` at 0.04. We note however that all correlations between binary ingredients variables and rating are disappointingly weak.

Given this low correlation between the "binary" ingredients categories and the 7-level rating, we decided to investigate if we could find a higher correlation by transforming the variable to a binary rating. We decide to put the threshold for a "bad" or "good" rating at 4. Unfortunately, the results are very similar to the 7-level rating variable, with very weak correlations.


```{r}
#corr plot
ingredients_df_bin %>% 
  mutate(rating_bin = ifelse(rating>4, 1, 0)) %>% 
  select(rating, rating_bin, contains("bin")) %>%
  plot_correlation()
```

##### Barplots - binary rating variable
Despite the low correlation with the binary rating, we still want to visualise it like we did above for the multilevel rating.

```{r}
ingredients_df_bin %>% 
  select(contains("bin"), rating) %>%
  mutate(rating_bin = ifelse(rating>4, "good", "bad"), across(everything(), as.factor)) %>% 
  select(-rating) %>% 
  plot_bar(by = "rating_bin", order_bar = FALSE)
```

We now have only 2 categories: recipes with rating above 4 and recipes with ratings below 4. There is no clear relationship in those graphs either, and this confirms the correlation results that we have found above in the correlation plot.

As far as interpretation goes, if we look at vegetables for example, we can see that the proportion of recipes with ratings above 4 is higher for recipes containing no vegetables, when compared to recipes containing at least one vegetable.

### "Total" engineered ingredients variables
```{r}
#Analysis which single ingredient is present in most recipes
df <- ingredients_df %>% 
  select(-title, -rating) %>% 
  pivot_longer(-ID, names_to = "ingredient", values_to = "value")


ing_top10 <- df %>% 
  group_by(ingredient) %>% 
  summarise(total = sum(value)) %>% 
  ungroup() %>% 
  arrange(desc(total)) %>% 
  dplyr::slice(1:10)

ing_top10 %>% 
  # mutate(ingredient = fct_rev(ingredient)) %>% 
  ggplot(aes(x=reorder(ingredient, total), y=total, fill=ingredient)) +
  geom_bar(stat = "identity") +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_discrete(guide = guide_axis(n.dodge=2))+
  labs(x = "Ingredient", y = "Value", title = "Total amount of recipes containing each ingredient\nTop 10")
```
As we can observe, many recipes contain milk cream, onion, tomato, salad, egg and garlic. Some of these are versatile as they can be used for many different kinds of recipes. Onion and garlic are widely used for giving flavour to many dishes, whereas egg and milk cream can be used to cook salty and sweet recipes.

#### Correlation between total number of ingredients per category and rating variable

```{r}
ingredients_df_total %>% 
  mutate(rating_bin = ifelse(rating>4, 1, 0)) %>% 
  select(rating, rating_bin, contains("total")) %>% 
  plot_correlation()
```
We notice a negative relationship between the number of fruits and number of vegetables which makes sense these two kinds of ingredients are rarely combined in a recipe. The same is true for the number of vegetables related to the number of desserts. The results are similar to the previous correlogram with the binary columns. In this case we do not notice any significant relationship between the multilevel rating rating and the other variables.

Results are disappointing again for the `rating_bin` variable, and remain in line with what we found so far. Correlations between total number of ingredients and both rating variable are very weak.

#### Amount of ingredients per recipe

The number of ingredients per recipe is more or less normally distributed, with a mean around 4.75.
```{r Plotting ingredients totals}
#checking some stuff about the new ingredients table
ingredients_df_total %>% 
  select(ID, title, total_ingredients) %>% 
  ggplot(aes(x=total_ingredients)) + 
  geom_bar() + geom_vline(aes(xintercept=mean(total_ingredients)),color="red", linetype="dashed", size=1)+
   scale_x_continuous(breaks = seq(1, 12, by = 1)) +
  labs(x="Number of ingredients per recipe", y = "Recipe Count", title = "Distrubution of number of ingredients per recipe")
```


```{r test of plot above, eval = FALSE}
#we notice that 117 (no NAs and RAT0, and not duplicated) recipes have 0 ingredients, let's investigate why and how that's possible
ingredients_df_total %>% 
  filter(total_ingredients==0)

#let's pick recipe ID number 1183 which should have poppy and sesame seeds according to the title
recipes %>% 
  filter(ID == 1183) %>% 
  select_if(~ any(. == 1))
#we can see that only 3 variables are equal to 1 here
recipes %>% 
  filter(ID == 365) %>% 
  select_if(~ any(. == 1))

recipes %>% 
  filter(ID == 1089) %>% 
  select_if(~ any(. == 1))

#####
#QUESTION: do we want to keep those recipes?
#####


ingredients_df_total %>% 
  filter(total_ingredients >10)
```

Based on this information, we decide to eliminate those 117 observations which don't contain any ingredients that we have classified in our vectors.
```{r}
#eliminating all recipes which do not contain any ingredients that we have classified in categories --> within the "all_ingredients" vector
index_zero_ingredient <- ingredients_df_full %>% 
  filter(total_ingredients == 0) %>% pull(ID)

#removing the 117 recipes with no ingredients listed from recipes and ingredients_df_full
recipes <- recipes %>% 
  filter(!ID %in% index_zero_ingredient)

ingredients_df_full <- ingredients_df_full %>%
  filter(!total_ingredients == 0)
```


Besides the total amount of ingredients, let's check the amount of ingredients per recipe for the top 3 categories in terms of ingredients frequency (i.e., vegetables, fruits, meats)

```{r}
show_nveg <- ingredients_df_full %>%
  filter(vegetables_bin == 1) %>% 
  select(ID, title, total_vegetables) %>% 
  ggplot(aes(x=total_vegetables)) + 
  scale_x_continuous(breaks = seq(1, 9, by = 1)) +
  geom_bar() + geom_vline(aes(xintercept=mean(total_vegetables)),color="blue", linetype="dashed", size=1)


show_nfruit <- ingredients_df_full %>%
  filter(fruits_bin == 1) %>% 
  select(ID, title, total_fruits) %>% 
  ggplot(aes(x=total_fruits)) + 
  scale_x_continuous(breaks = seq(1, 9, by = 1)) +
  geom_bar() + geom_vline(aes(xintercept=mean(total_fruits)),color="blue", linetype="dashed", size=1)


# ingredients_df_full %>% 
#   select(ID, title, total_meat) %>% 
#   ggplot(aes(x=total_meat)) + 
#   geom_bar() + geom_vline(aes(xintercept=mean(total_meat)),color="blue", linetype="dashed", size=1)+
#   labs(x="Number of meats per recipe", y = "Recipe Count", title = "Distrubution of number of meats per recipe")

#let's try to filter by recipes which contain meat to see if my functions work
show_nmeat <- ingredients_df_full %>% 
  filter(meats_bin == 1) %>% 
  select(ID, title, total_meat) %>% 
  ggplot(aes(x=total_meat)) + 
  geom_bar() + geom_vline(aes(xintercept=mean(total_meat)),color="blue", linetype="dashed", size=1)+
  labs(x="Number of meats per recipe", y = "Recipe Count", title = "Distrubution of number of meats per recipe")

#why do we still have value in 0 meats --> it was because when creating the total meat column in ingredients_df_test I did not include the general meat category

grid.arrange(show_nveg, show_nfruit, show_nmeat, ncol=2, nrow =2)

```
As we can observe, most of the recipes have 1 or 2 vegetables and rarely more than 4. The same is true for fruits. Concerning the meat, it usual to see one kind of meat, but rare to see 3 or more in the same recipe.


## Mixed EDA - ingredients and nutritional value

```{r Left joins to aggregate the data}

recipes_select <- recipes %>% 
  select(ID, title, rating, calories, protein, sodium, fat)

ingredients_select <- ingredients_df_total %>% 
  select(ID, all_of(contains("total")))

recipes_more <- recipes_select %>%
  left_join(ingredients_select, 
           by=c('ID'))

ingredients_bin_select <- ingredients_df_bin %>% 
  select(ID, contains("bin"))


recipes_full <- recipes_more %>%
  left_join(ingredients_bin_select, 
           by=c('ID'))

```

### Correlation between nutritional values and engineered ingredients variables
```{r}
recipes_full %>% 
  select(-ID) %>% 
  plot_correlation()
```
For instance we notice a positive correlation between proteins and meats_bin which includes all sorts of meat. Another visible positive correlation is the one between sodium and seafood_bin. We might also want to investigate the relationship between calories and carbs_bin.


### Barplot and boxplot - Meat and Proteins
```{r fig.width=7}

meat_average01 <- recipes_full %>% 
  group_by(meats_bin) %>% 
  summarise(avg_protein = mean(protein))

# Barplot
barplot1 <- recipes_full %>% 
  ggplot(aes(x = factor(meats_bin), y = protein)) +
  stat_summary(fun = mean, geom = "bar") +
  ggtitle("Average amount of proteins per recipe with and without meat") +
  xlab("Presence of Meat or not") +
  ylab("Protein Content in grams")

# Boxplots per different kinds of meat
recipes_general <- recipes_full %>% 
  select(ID) %>% 
  left_join(recipes, 
           by=c('ID'))

recipes_meat <- recipes_general %>% 
  select(ID, title, rating, calories, protein, fat, sodium, all_of(all_meats))

recipes_meat <- recipes_meat %>% 
  pivot_longer(cols=c("beef", "beef_rib", "beef_shank", "beef_tenderloin", "brisket", "ground_beef", "hamburger", "veal", "bacon", "ham", "pork", "pork_chop", "pork_rib", "pork_tenderloin", "prosciutto", "ground_lamb", "lamb", "lamb_chop", "lamb_shank", "rack_of_lamb", "chicken", "duck", "goose", "poultry", "poultry_sausage", "quail", "turkey", "meatball", "meatloaf", "rabbit", "sausage", "steak", "venison" ),
                    names_to='meats',
                    values_to='yes_or_no') %>% 
  filter(yes_or_no == 1)

multi_boxplot1 <- recipes_meat %>% 
  filter(protein < 450) %>%
  ggplot(aes(x=meats, y=protein, fill=meats)) +
  geom_boxplot(alpha=0.3) +
  theme(legend.position="none",
          plot.title = element_text(size=11)) +
  scale_y_continuous(breaks=seq(0,7000,25)) +
  coord_flip() +
  ggtitle("Distribution of proteins per recipe according to different kinds of meat") +
  xlab("Meats") +
  ylab("Protein Content in grams") +
  theme(legend.position="none") 

# Here we want to show which kinds of meat specifically have a high level of proteins

grid.arrange(barplot1, multi_boxplot1, ncol=2, nrow =1)
```
It is very clear that among the recipes with meat, the average content of protein is higher than in recipes without meat. Among those that have meat we notice that goose, venison and lamb shank have the highest content of protein.

### Barplot and boxplot - Seafood and Sodium
```{r fig.width=7}

seafood_average01 <- recipes_full %>% 
  group_by(seafood_bin) %>% 
  summarise(avg_seafood = mean(sodium))

# Seafood and sodium
barplot2 <- recipes_full %>% 
  ggplot(aes(x = factor(seafood_bin), y = sodium)) +
  stat_summary(fun = mean, geom = "bar") +
  ggtitle("Average amount of sodium per recipe with and without seafood")  +
  xlab("Presence of Seafood or not") +
  ylab("Sodium Content in milligrams")


# Boxplots per different kinds of seafood

recipes_seafood <- recipes_general %>% 
  select(ID, title, rating, calories, protein, fat, sodium, all_of(seafood_vec))

recipes_seafood <- recipes_seafood %>% 
  pivot_longer(cols=c("clam", "crab", "lobster", "mussel", "octopus", "oyster", "scallop", "shellfish", "shrimp", "squid" ),
                    names_to='seafoods',
                    values_to='yes_or_no') %>% 
  filter(yes_or_no == 1)

multi_boxplot2 <- recipes_seafood %>% 
  filter(sodium < 10000) %>%
  ggplot(aes(x=seafoods, y=sodium, fill=seafoods)) +
  geom_boxplot(alpha=0.3) +
  theme(legend.position="none",
          plot.title = element_text(size=11)) +
  scale_y_continuous(breaks=seq(0,30000,500)) +
  coord_flip() +
  ggtitle("Distribution of sodium per recipe according to different kinds of seafood") +
  xlab("Seafood") +
  ylab("Sodium Content in milligrams") +
  theme(legend.position="none") 

# Here we want to show which kinds of seafood specifically have a high level of sodium

grid.arrange(barplot2, multi_boxplot2, ncol=2, nrow =1)
```
In this case it is very clear that among the recipes with seafood, the average content of sodium is higher than in recipes without seafood. Among those that have seafood we notice that clams and lobsters have the highest content of sodium.

### Barplot and boxplot - Carbs and Calories
```{r fig.width=7}

carbs_average01 <- recipes_full %>% 
  group_by(carbs_bin) %>% 
  summarise(avg_carbs = mean(calories))

# Carbs and calories
barplot3 <- recipes_full %>% 
  ggplot(aes(x = factor(carbs_bin), y = calories)) +
  stat_summary(fun = mean, geom = "bar") +
  ggtitle("Average amount of calories per recipe with and without carbohydrates") +
  xlab("Presence of carbohydrates or not") +
  ylab("Calories content")

# Afterwards we would also want to show which kinds of carbs specifically have a high number of calories


# Boxplots per different kinds of carbs
recipes_carbs <- recipes_general %>% 
  select(ID, title, rating, calories, protein, fat, sodium, all_of(carbs_vec))

recipes_carbs <- recipes_carbs %>% 
  pivot_longer(cols=c("brown_rice", "chickpea", "cornmeal", "couscous", "hominy_cornmeal_masa", "orzo", "pasta", "potato", "rice", "semolina", "sweet_potato_yam", "wild_rice"),
                    names_to='carbs',
                    values_to='yes_or_no') %>% 
  filter(yes_or_no == 1)

multi_boxplot3 <- recipes_carbs %>% 
  filter(sodium < 10000) %>%
  ggplot(aes(x=carbs, y=calories, fill=carbs)) +
  geom_boxplot(alpha=0.3) +
  theme(legend.position="none",
          plot.title = element_text(size=11)) +
  scale_y_continuous(breaks=seq(0,7000,500)) +
  coord_flip() +
  ggtitle("Distribution of calories per recipe according to different kinds of food high in carbohydrates") +
  xlab("Carbs") +
  ylab("Calories Content") +
  theme(legend.position="none") 

grid.arrange(barplot3, multi_boxplot3, ncol=2, nrow =1)
```
Recipes which contain carbs register a higher average content of calories than recipes without carbs. Among those that have carbs we notice that pasta and chickpeas are the richest in calories.

## Seasons, Recipe Type, and Countries EDA

### Seasons
```{r}
#Create seasons df
seasons_df <- recipes %>% 
  select(ID, rating, all_of(seasons_vec)) %>% 
  filter(if_any(all_of(seasons_vec)) == 1) %>% 
  mutate(sum_season = rowSums(across(all_of(seasons_vec))), rating_bin = ifelse(rating>4, 1, 0)) %>% 
  relocate(rating_bin, .after = rating)

seasons_df %>%
ggplot(aes(x=sum_season)) +
  geom_bar()

# seasons_df %>% 
#   filter(sum_season==3)
# 
# seasons_df %>% 
#   filter(sum_season==4)
#total of 29 recipes with either 3 or 4 --> let's discard them

#let's look a bit more closely to those with 2 seasons to see if they are next to each other or not

# seasons_df %>% 
#   filter(sum_season==2)

### should we keep those observations??? no
#removing obs with more than one season
seasons_df <- seasons_df %>% 
  filter(sum_season==1)
```

As we can see, there is again no correlation between seasons and recipe ratings, be it the 7-level rating or the binary rating.

```{r}
seasons_df %>% 
  select(-sum_season, -ID) %>% 
  plot_correlation()
```
### Recipe Type

```{r Recipe Type EDA}
#taking into account only the "main" recipe types
recipe_types_select <- c("breakfast", "brunch", "dessert", "dinner", "lunch")

type_df <- recipes %>% 
  select(ID, rating, all_of(recipe_types_select)) %>% 
  filter(if_any(all_of(recipe_types_select)) == 1) %>% 
  mutate(sum_type = rowSums(across(all_of(recipe_types_select))), rating_bin = ifelse(rating>4, 1, 0)) %>% 
  relocate(rating_bin, .after = rating)

type_df %>% 
  ggplot(aes(x=sum_type)) +
  geom_bar()

# type_df %>% 
#   filter(sum_type == 2)

# left with 3333 obs after filtering
type_df <- type_df %>% 
  filter(!sum_type >1)
```

Once again very low correlation for recipe types relative to either rating variables, we will not included them in the analysis.
```{r}
type_df %>% 
  select(-c(ID, sum_type)) %>% 
  plot_correlation()
```

### Countries
Only 54 recipes containing info about the country so we cannot use it either for the analysis.
```{r Countries EDA}
countries_df <- recipes %>% 
  select(ID, rating, all_of(countries)) %>% 
  filter(if_any(all_of(countries)) == 1) %>% 
  mutate(sum_type= rowSums(across(all_of(countries))))

countries_df %>% 
  ggplot(aes(x=sum_type)) +
  geom_bar()
```



## Exploratory PCA Analysis
- With all variables 680

```{r}

recipes_pca <- recipes %>% 
  select(-ID, -title) %>% 
  PCA(ncp = 679, graph = FALSE)

recipes_pca

fviz_pca_var(recipes_pca)
```
Hard to interpret this PCA output. The two dimensions explain together only 2.1% of the variability in the data.

```{r}

fviz_contrib(recipes_pca, choice = "var", axes = 1)
fviz_contrib(recipes_pca, choice = "var", axes = 2)

```
Also in this case it difficult to understand which are contributing to each dimension since the dimension itself accounts for a little percentage of variability.


```{r}

fviz_pca_biplot(recipes_pca) ## biplot

```

```{r}

fviz_eig(recipes_pca, addlabels = TRUE, ncp=11)


```
## Exploratory PCA Analysis
- All the variables unless "useless" ones such as us_cities or chef
```{r}

ingredients_df_pca <- ingredients_df %>% 
  select(-title, -ID)

recipes_pca2 <- PCA(ingredients_df_pca, ncp = 33, graph = FALSE)
fviz_eig(recipes_pca2, addlabels = TRUE, ncp=11)

```


### Exploratory PCA Analysis
- Only with nutritional variables, total and bin variables
```{r}
nutritional_df <- recipes %>% 
  select(ID, all_of(nutritional_values))

recipes_analysis <- ingredients_df_full %>% 
  left_join(nutritional_df, by="ID") %>% 
  mutate(across(all_of(contains("bin"))), ID = as.character(ID)) %>% 
  select(rating, all_of(nutritional_values), contains("bin"), contains("total"))
```

```{r}

recipes_pca3 <- PCA(recipes_analysis, ncp = 33, graph = FALSE)

recipes_pca3

fviz_pca_var(recipes_pca3)
```


```{r}

fviz_contrib(recipes_pca3, choice = "var", axes = 1)
fviz_contrib(recipes_pca3, choice = "var", axes = 2)

```

```{r}

fviz_pca_biplot(recipes_pca3) ## biplot

```

```{r}

fviz_eig(recipes_pca3, addlabels = TRUE, ncp=11)

```

```{r}

p1 <- fviz_pca_biplot(recipes_pca3, axes = 1:2) 
p2 <- fviz_pca_biplot(recipes_pca3, axes = 3:4) 
p3 <- fviz_pca_biplot(recipes_pca3, axes = 5:6) 
p4 <- fviz_pca_biplot(recipes_pca3, axes = 7:8) 
p5 <- fviz_pca_biplot(recipes_pca3, axes = 9:10) 

grid.arrange(p1, p2, p3, p4, p5, nrow = 3, ncol=2)

```


```{r eval=FALSE}

recipe_hc2 <- hclust(dist(recipes_analysis, method = "manhattan"))

recipe_clust2 <- cutree(recipe_hc2, k = 10)

fviz_pca_biplot(recipes_pca3,
             col.ind = factor(recipe_clust2))

```

